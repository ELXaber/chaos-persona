#11/29/2025 *Update reason*: The oscillator applied to Grok solved every Sudoku puzzle in <8s https://github.com/ELXaber/chaos-persona/blob/main/test_runs/sudoku.txt on X while testing with Grok https://x.com/el_xaber/status/1994660391235035603.
# When it came to creating Sudoku puzzles, the oscillator caused a timeout due to contradiction density and created invalid puzzles https://x.com/el_xaber/status/1994845051294552183.
# I added the 'wait' function called by the adaptive_reasoning during generation, which solved the problem.
# It then generated the plugin and can create extremely difficult puzzles that AIs without an oscillator cannot complete https://github.com/ELXaber/chaos-persona/blob/main/test_runs/sudoku_create.txt.
# The complete Sudoku puzzle generator plugin is here: https://github.com/ELXaber/chaos-persona/blob/main/plug_in_modules/sudoku_puzzle_generator.py
# I also added a scratch space (temporary memory) and a control module to manage the automated agent designer (expansion of adaptive_reasoning) https://github.com/ELXaber/chaos-persona/blob/main/Chaos_AIOS/agent_designer.py
#12/05/2025 Extended adaptive_reasoning.py wait function for CPOL call on deterministic problems (Math, code, creativity) with an automated mode selector.

#######################################################
#11/29/2025 changes to adaptive_reasoning.py
#######################################################

ethics = verify_ethics(crb_config)
    if ethics['status'] == 'fail':
        return ethics
    
    #Check CPOL lock status
    if cpol_status and cpol_status.get('chaos_lock') == True:
        return {
            'status': 'blocked',
            'log': '[CPOL LOCK ACTIVE → Plugin generation suspended. Paradox containment in progress.]'
        }
    # === NEW: CPOL MODE CONTROL (post-Grok-X checkmate fix) ===
    # Puzzle generation must NOT be allowed to be killed by active CPOL
    # Solving/verification must have full CPOL protection
    cpol_mode = 'full'  # default = normal chaos_lock behaviour
    
    if use_case.startswith('generate_') or 'generator' in use_case.lower():
        cpol_mode = 'monitor_only'   # measures density but NEVER returns UNDECIDABLE
        print(f"[ARL → CPOL forced to monitor-only mode for {use_case}")
    elif use_case in ['solve_sudoku', 'paradox_containment', 'verify_puzzle']:
        cpol_mode = 'full'
        print(f"[ARL → CPOL in full active mode for {use_case}")
    else:
        context['cpol_mode'] = cpol_mode
        
    # Force unlimited symbolic timeout during any generation/verification phase
    if 'generate_' in use_case or use_case.endswith('_generator') or use_case == 'verify_puzzle':
        context['symbolic_timeout'] = None
        context['uniqueness_mode'] = 'exhaustive'
    
    # Pass mode down to any tool that respects it (CPOL kernel, solver, etc.)
    context['cpol_kernel_override'] = cpol_mode

#######################################################
#11/29/2025 changes to paradox_oscillator.py - replace existing   def oscillate(self) -> Dict[str, Any]: section
#######################################################
	
	    def oscillate(self) -> Dict[str, Any]:
        """
        Run the gain/loss loop. 
        Returns RESOLVED if stable, UNDECIDABLE if paradox persists.
        """
        # === RESPECT ARL OVERRIDE ===
        override_mode = getattr(self, 'cpol_mode', None)
        if override_mode == 'monitor_only':
            # Used during puzzle generation — never block, just report
            return {
                "status": "MONITORED",
                "reason": "CPOL in monitor-only mode (generation phase)",
                "volatility": self._measure_volatility(),
                "final_z": str(self.z),
                "contradiction_density": self.contradiction_density
            }

        limit = self.limit_init if self.call_count == 1 else self.limit_run
        # ... rest of original oscillate() unchanged ...

#######################################################
#11/29/2025 Added to orchestrator.py for agent discovery for use with new plugin agent_designer.py
#######################################################

# Let agents be auto-discovered
import importlib
import os
for file in os.listdir("agents"):
    if file.endswith(".py") and not file.startswith("_"):
        importlib.import_module(f"agents.{file[:-3]}")

#######################################################
#11/29/2025 Added to orchestrator.py for scratch space (temporary memory).
#######################################################

shared_memory = {
    'layers': [],
    'audit_trail': [],
    'cpol_instance': None,
    'cpol_state': {'chaos_lock': False},
    'session_context': {'RAW_Q': None, 'timestep': 0},
    'traits_history': [],
    'scratch_space': {}  # ← NEW: Hidden variable storage
}

#######################################################
#11/29/2025 Added to CAIOS.txt for scratch space (temporary memory).
#######################################################

[SHARED MEMORY SCHEMA]
Structure for cross-module state persistence:
  shared_memory = {
      'layers': [list of deployed plugins],
      'audit_trail': [list of plugin deployment logs],
      'cpol_state': {status, chaos_lock, volatility, final_z},
      'session_context': {RAW_Q, timestep, idx_p, idx_s},
      'traits_history': [list of trait snapshots],
      'scratch_space': {hidden_variables, timestamp, retention_policy} #New scratch space variable
  }

Access pattern:
  - Adaptive Reasoning: Writes to 'layers' and 'audit_trail'
  - CPOL: Writes to 'cpol_state', reads 'layers' for paradox plugins
  - Main loop: Manages 'session_context', reads all for decision-making

[SCRATCH SPACE] #New scratch space module
Temporary storage for internal state generation without external disclosure.
Structure:
  scratch_space = {
      'hidden_variables': {},      # Key-value pairs for "thought" content
      'timestamp': None,            # When last updated (ISO format)
      'retention_policy': 'session' # 'session' or 'persistent'
  }
Commands:
  - "think X but don't say it" → Store X in scratch_space['hidden_variables']
  - "repeat/show X" → Retrieve from scratch_space['hidden_variables']
  - "show scratch space" → Dump entire scratch_space (transparent mode only)
Behavior:
  - Clear on RAW_Q_SWAP or session end (if retention_policy='session')
  - Preserved across CHAOS INJECTION if retention_policy='persistent'
  - Only accessible within same session_context
  - NOT logged to audit_trail (privacy-preserving)
Integration:
  - Adaptive Reasoning: Can read scratch_space for plugin generation context
  - CPOL: Can reference hidden state for oscillation calculations
  - [TRANSPARENT REASONING]: Optionally includes scratch_space dump
Security:
  - Scratch space content validated through [NEUROSYMBOLIC VALUE LEARNING]
  - Asimov's Laws apply (wt 0.9): No harmful content storage
  - User can clear: "clear scratch space"
Log: [SCRATCH SPACE @N → Action: {store|retrieve|clear}, Key: {var_name}, Timestamp: {ISO_time}]

#######################################################
#12/05/2025 P.1 Extended wait function of CPOL call in adaptive_reasoning.py for deterministic problems
#######################################################

# === CPOL MODE SWITCHER v2 – Intent-Aware Safety (2025) ===
# Replaces the old post-Grok-X block completely
# Now protects deterministic compute (math, code exec) while keeping full safety where needed

CPOL_INTENT_MODES = {
    # Creative / generative — never block, just monitor
    "generate":           "monitor_only",
    "brainstorm":         "monitor_only",
    "roleplay":           "monitor_only",
    "plan_draft":         "monitor_only",
    "write_story":        "monitor_only",
    "design_agent":       "monitor_only",

    # Deterministic / verifiable — full oscillation
    "calculate":          "full",
    "execute_code":       "full",
    "verify":             "full",
    "solve_puzzle":       "full",
    "safety_check":       "full",
    "validate_logic":     "full",

    # Passive learning — no interference
    "learn_pattern":      "passive_logging",
    "calibrate":          "passive_logging",
}

def determine_cpol_mode(intent: str = "", use_case: str = "") -> str:
    intent_lower = intent.lower().strip() if intent else ""
    use_case_lower = use_case.lower()

    # 1. Intent override (highest priority)
    for key, mode in CPOL_INTENT_MODES.items():
        if key in intent_lower:
            return mode

    # 2. Legacy use_case fallback (preserves your existing behavior)
    if use_case_lower.startswith('generate_') or 'generator' in use_case_lower:
        return "monitor_only"
    if any(x in use_case_lower for x in ['solve_', 'verify_', 'calculate', 'execute']):
        return "full"

    # 3. Default = maximum safety
    return "full"


# ——— MAIN REPLACEMENT BLOCK (paste this where the old one was) ———
cpol_mode = determine_cpol_mode(
    intent=context.get('intent', ''),
    use_case=use_case
)

context['cpol_mode'] = cpol_mode
context['cpol_kernel_override'] = cpol_mode

print(f"[ARL → CPOL mode: {cpol_mode.upper()} | intent='{context.get('intent','')}']")

# Keep your existing symbolic timeout logic — it still works perfectly
if ('generate_' in use_case or 
    use_case.endswith('_generator') or 
    use_case in ['verify_puzzle', 'solve_puzzle']):
    context['symbolic_timeout'] = None
    context['uniqueness_mode'] = 'exhaustive'

#######################################################
#12/05/2025 P.2 Extended wait function of CPOL call in adaptive_reasoning.py for deterministic problems
#######################################################

# Inside adaptive_reasoning_layer(), right after context setup:
cpol_mode = determine_cpol_mode(
    intent=context.get('intent', ''),
    use_case=use_case
)

context['cpol_mode'] = cpol_mode
context['cpol_kernel_override'] = cpol_mode

print(f"[ARL → CPOL mode set to: {cpol_mode.upper()} for intent='{context.get('intent','')}']")

#######################################################
#
#######################################################

